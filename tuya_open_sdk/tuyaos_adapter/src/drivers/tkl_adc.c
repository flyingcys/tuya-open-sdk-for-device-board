/**
 * @file tkl_adc.c
 * @brief this file was auto-generated by tuyaos v&v tools, developer can add implements between BEGIN and END
 * 
 * @warning: changes between user 'BEGIN' and 'END' will be keeped when run tuyaos v&v tools
 *           changes in other place will be overwrited and lost
 *
 * @copyright Copyright 2020-2021 Tuya Inc. All Rights Reserved.
 * 
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "freertos/FreeRTOS.h"
#include "esp_adc/adc_oneshot.h"
#include "esp_adc/adc_cali.h"
#include "esp_adc/adc_cali_scheme.h"
#include "esp_adc/adc_continuous.h"
#include "hal/adc_types.h"

#include "esp_err.h"
#include "esp_log.h"
#include "soc/soc_caps.h"

#include "tuya_error_code.h"
#include "tuya_cloud_types.h"

#include "tkl_memory.h"
#include "tkl_system.h"
#include "tkl_output.h"
#include "tkl_adc.h"

#define ADC_DEV_NUM         1
#define ADC_MV_TO_UV        1000

// #if CONFIG_IDF_TARGET_ESP32
// #define ADC_CONV_MODE       ADC_CONV_SINGLE_UNIT_1  //ESP32 only supports ADC1 DMA mode
// #define ADC_OUTPUT_TYPE     ADC_DIGI_OUTPUT_FORMAT_TYPE1
// #elif CONFIG_IDF_TARGET_ESP32S2
// #define ADC_CONV_MODE       ADC_CONV_BOTH_UNIT
// #define ADC_OUTPUT_TYPE     ADC_DIGI_OUTPUT_FORMAT_TYPE2
// #elif CONFIG_IDF_TARGET_ESP32C3 || CONFIG_IDF_TARGET_ESP32H2 || CONFIG_IDF_TARGET_ESP32C2
// #define ADC_CONV_MODE       ADC_CONV_ALTER_UNIT     //ESP32C3 only supports alter mode
// #define ADC_OUTPUT_TYPE     ADC_DIGI_OUTPUT_FORMAT_TYPE2
// #elif CONFIG_IDF_TARGET_ESP32S3
// #define ADC_CONV_MODE       ADC_CONV_BOTH_UNIT
// #define ADC_OUTPUT_TYPE     ADC_DIGI_OUTPUT_FORMAT_TYPE2
// #endif

typedef struct
{
    const TUYA_ADC_NUM_E adc_num;
    const UINT32_T gpio_num;
    int adc_int_flag;
    const UINT32_T adc_gpio;
    const UINT32_T adc_ch;
}adc_pin_map_t;

//static UINT32_T g_adc_used_gpio_num = 0;

typedef enum {
    ADC_CH0,
    ADC_CH1,
    ADC_CH2,
    ADC_CH_MAX,
} ADC_CH_E;

static adc_pin_map_t adc_pin_map[] = {
     {TUYA_ADC_NUM_0, TUYA_GPIO_NUM_20, 0, ADC_CHANNEL_2, ADC_CH2},
     {TUYA_ADC_NUM_0, TUYA_GPIO_NUM_14, 0, ADC_CHANNEL_0, ADC_CH0}, 
     {TUYA_ADC_NUM_0, TUYA_GPIO_NUM_15, 0, ADC_CHANNEL_1, ADC_CH1} 
};

const char ADC_PIN_MAP_NUM = sizeof(adc_pin_map) / sizeof(adc_pin_map[0]);
adc_oneshot_unit_handle_t adc_handle;
#if 0
//通过GPIO查找num和ch
int adc_find_port_ch(UINT32_T adc_gpio_num, UINT32_T *adc_num, UINT32_T *adc_ch)
{
    int i = 0;
    for(i = 0; i< ADC_PIN_MAP_NUM; i++)
    {
        if (adc_gpio_num == adc_pin_map[i].gpio_num)
        {
            *adc_num = adc_pin_map[i].adc_num;
            *adc_ch = adc_pin_map[i].adc_ch;
            break;
        }
    }
    if(i >= ADC_PIN_MAP_NUM)
    {
        return OPRT_COM_ERROR;
    }

    return OPRT_OK;
}

//初始化时查找通道接口
static int adc_find_gpio_by_channel(TUYA_ADC_NUM_E adc_num, UINT32_T adc_ch, UINT32_T *used_gpio, UINT32_T *init_flag)
{
    if ((used_gpio == NULL) || (init_flag == NULL))
    {
        return OPRT_OS_ADAPTER_INVALID_PARM;
    }
    
    int i = 0;
    for (i = 0; i < ADC_PIN_MAP_NUM; i++)
    {
        if ((adc_num == adc_pin_map[i].adc_num) && (adc_ch & BIT(adc_pin_map[i].adc_ch)))
        {
            *used_gpio = adc_pin_map[i].adc_gpio;
            adc_pin_map[i].adc_int_flag = 1;
            *init_flag = adc_pin_map[i].adc_int_flag;
            break;
        }
    }

    if(i >= ADC_PIN_MAP_NUM)
    {
        return OPRT_COM_ERROR;
    }

    return OPRT_OK;
}


//读数据时查找通道接口
static int adc_check_input_gpio_valid(TUYA_ADC_NUM_E port_num, UINT32_T used_gpio, UINT32_T *init_flag)
{
    int i = 0;
    for (i = 0; i < ADC_PIN_MAP_NUM; i++)
    {
        if ((port_num == adc_pin_map[i].adc_num) && (used_gpio == adc_pin_map[i].adc_gpio))
        {
            *init_flag = adc_pin_map[i].adc_int_flag;
            break;
        }
    }

    if(i >= ADC_PIN_MAP_NUM)
    {
        return OPRT_NOT_FOUND;
    }

    return OPRT_OK;
}


//deinit时查找通道接口
static int adc_find_channel_deinit(TUYA_ADC_NUM_E adc_num, UINT32_T used_gpio, UINT32_T *init_flag)
{
    if (init_flag == NULL)
    {
        return OPRT_OS_ADAPTER_INVALID_PARM;
    }

    int i = 0;
    for (i = 0; i < ADC_PIN_MAP_NUM; i++)
    {
        if ((adc_num == adc_pin_map[i].adc_num) && (used_gpio == adc_pin_map[i].adc_gpio))
        {
            adc_pin_map[i].adc_int_flag = 0;
            *init_flag = adc_pin_map[i].adc_int_flag;
            break;
        }
    }

    if(i >= ADC_DEV_NUM){
        return OPRT_COM_ERROR;
    }

    return OPRT_OK;
}


static bool adc_calibration_init(adc_unit_t unit, adc_atten_t atten, adc_cali_handle_t *out_handle)
{
    adc_cali_handle_t handle = NULL;
    esp_err_t ret = ESP_FAIL;
    bool calibrated = false;

#if ADC_CALI_SCHEME_CURVE_FITTING_SUPPORTED
    if (!calibrated) {
        ESP_LOGI(TAG, "calibration scheme version is %s", "Curve Fitting");
        adc_cali_curve_fitting_config_t cali_config = {
            .unit_id = unit,
            .atten = atten,
            .bitwidth = ADC_BITWIDTH_DEFAULT,
        };
        ret = adc_cali_create_scheme_curve_fitting(&cali_config, &handle);
        if (ret == ESP_OK) {
            calibrated = true;
        }
    }
#endif

#if ADC_CALI_SCHEME_LINE_FITTING_SUPPORTED
    if (!calibrated) {
        ESP_LOGI(TAG, "calibration scheme version is %s", "Line Fitting");
        adc_cali_line_fitting_config_t cali_config = {
            .unit_id = unit,
            .atten = atten,
            .bitwidth = ADC_BITWIDTH_DEFAULT,
        };
        ret = adc_cali_create_scheme_line_fitting(&cali_config, &handle);
        if (ret == ESP_OK) {
            calibrated = true;
        }
    }
#endif

    *out_handle = handle;
    if (ret == ESP_OK) {
        ESP_LOGI(TAG, "Calibration Success");
    } else if (ret == ESP_ERR_NOT_SUPPORTED || !calibrated) {
        ESP_LOGW(TAG, "eFuse not burnt, skip software calibration");
    } else {
        ESP_LOGE(TAG, "Invalid arg or no memory");
    }

    return calibrated;
}
#endif
OPERATE_RET tkl_adc_init(TUYA_ADC_NUM_E port_num, TUYA_ADC_BASE_CFG_T *cfg)
{
    adc_oneshot_unit_init_cfg_t adc_cfg;
    //adc_oneshot_unit_handle_t adc_handle;
    adc_oneshot_chan_cfg_t adc_chan_cfg;
    //adc_cali_handle_t adc_cali_handle;
    
    adc_cfg.unit_id = ADC_UNIT_1;

    adc_oneshot_new_unit(&adc_cfg, &adc_handle);

    adc_chan_cfg.bitwidth = ADC_BITWIDTH_DEFAULT;
    adc_chan_cfg.atten = ADC_ATTEN_DB_11;

    adc_oneshot_config_channel(adc_handle, ADC_CHANNEL_2, &adc_chan_cfg);
    adc_oneshot_config_channel(adc_handle, ADC_CHANNEL_3, &adc_chan_cfg);
    //adc_cali_handle = adc_calibration_init(ADC_UNIT_1, ADC_ATTEN_DB_11, &adc_cali_handle);

    return OPRT_OK;
}

/**
 * @brief: ADC 适配转换，ADC检测范围0~3.3V
 * @param[in]: 
 * @return: OPRT_OK
 */
OPERATE_RET tkl_adc_read_data(TUYA_ADC_NUM_E port_num, INT32_T *buff, UINT16_T len)
{
    //int voltage[2][10];
    adc_oneshot_read(adc_handle, ADC_CHANNEL_2, buff);
    //adc_cali_raw_to_voltage(adc_handle, buff, &voltage[0][1]);
    return OPRT_OK;
}

OPERATE_RET tkl_adc_deinit(TUYA_ADC_NUM_E port_num)
{
    adc_oneshot_del_unit(adc_handle);
    //adc_calibration_deinit(adc_cali_handle);
    return OPRT_OK;
}

/**
 * @brief get adc width
 * 
 * @param[in] port_num: adc unit number

 *
 * @return adc width
 */
UINT8_T tkl_adc_width_get(TUYA_ADC_NUM_E port_num)
{
    return OPRT_NOT_SUPPORTED;
}

/**
 * @brief get adc reference voltage
 * 
 * @param[in] NULL

 *
 * @return adc reference voltage(bat: mv)
 */
UINT32_T tkl_adc_ref_voltage_get(TUYA_ADC_NUM_E port_num)
{
    return OPRT_NOT_SUPPORTED;
}

/**
 * @brief adc get temperature
 *
 * @return temperature(bat: 'C)
 */
INT32_T tkl_adc_temperature_get(VOID_T)
{
    return OPRT_NOT_SUPPORTED;
}

/**
 * @brief read single channel
 *
 * @param[in] port_num: adc unit number
 * @param[in] ch_num: channel number in one unit
 * @param[out] buf: convert result buffer
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 *
 */
OPERATE_RET tkl_adc_read_single_channel(TUYA_ADC_NUM_E port_num, UINT8_T ch_id, INT32_T *data)
{
    return OPRT_NOT_SUPPORTED;
}

OPERATE_RET tkl_adc_read_voltage(TUYA_ADC_NUM_E port_num, INT32_T *buff, UINT16_T len)
{
    return OPRT_NOT_SUPPORTED;
}
