/**
 * @file tkl_timer.c
 * @brief this file was auto-generated by tuyaos v&v tools, developer can add implements between BEGIN and END
 * 
 * @warning: changes between user 'BEGIN' and 'END' will be keeped when run tuyaos v&v tools
 *           changes in other place will be overwrited and lost
 *
 * @copyright Copyright 2020-2021 Tuya Inc. All Rights Reserved.
 * 
 */
#include "freertos/FreeRTOS.h"
#include "esp_err.h"
#include "esp_log.h"
#include "driver/gptimer.h"

#include "tuya_error_code.h"
#include "tuya_cloud_types.h"
#include "tkl_system.h"
#include "tkl_memory.h"
#include "tkl_timer.h"
#include "tkl_output.h"

#define TIMER_DEV_NUM           3
#define DEFAUT_PERIOD 1000 //us

typedef struct {
    TUYA_TIMER_BASE_CFG_T cfg;
    unsigned int us;
} TIMER_CFG_T;

typedef struct {
    gptimer_handle_t time_handle;
    TIMER_CFG_T *timer_cfg;
} TIMER_DEV_T;


static TIMER_DEV_T s_timer_dev[TIMER_DEV_NUM] = {
        {NULL, NULL},{NULL, NULL},{NULL, NULL}
};

#define CHECK_TIMER_PARAM(ID) do {                                  \
    if (ID >= TIMER_DEV_NUM) {                                      \
        return OPRT_INVALID_PARM;                                   \
    }                                                               \
    if (NULL == s_timer_dev[ID].timer_cfg) {                        \
        return OPRT_INVALID_PARM;                                   \
    }                                                               \
} while (0);

static bool tkl_timer_handle(gptimer_handle_t timer, const gptimer_alarm_event_data_t *data, void *ctx)
{
    TUYA_TIMER_NUM_E timer_id = *(TUYA_TIMER_NUM_E *)ctx;
    if (timer_id >= TIMER_DEV_NUM) {                             
        return OPRT_INVALID_PARM;                       
    }

    if (s_timer_dev[timer_id].timer_cfg && s_timer_dev[timer_id].timer_cfg->cfg.cb) {
        s_timer_dev[timer_id].timer_cfg->cfg.cb(ctx);
    }

    return OPRT_OK;
}


/**
 * @brief timer init
 * 
 * @param[in] timer_id timer id
 * @param[in] cfg timer configure
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_timer_init(TUYA_TIMER_NUM_E timer_id, TUYA_TIMER_BASE_CFG_T *cfg)
{
    //esp_err_t ret;
    gptimer_handle_t timer_handle;
    gptimer_config_t timer_config;

    if (timer_id >= TIMER_DEV_NUM) {                             
        return OPRT_INVALID_PARM;                       
    } 

    if (s_timer_dev[timer_id].timer_cfg == NULL) {
        s_timer_dev[timer_id].timer_cfg = (TIMER_CFG_T *)tkl_system_malloc(sizeof(TIMER_CFG_T));
        if(NULL == s_timer_dev[timer_id].timer_cfg) {
            return OPRT_MALLOC_FAILED;
        }
    }

    memset(s_timer_dev[timer_id].timer_cfg, 0, sizeof(TIMER_CFG_T));
    s_timer_dev[timer_id].timer_cfg->cfg.mode = cfg->mode;
    s_timer_dev[timer_id].timer_cfg->cfg.args = cfg->args;
    s_timer_dev[timer_id].timer_cfg->cfg.cb = cfg->cb;

    memset(&timer_config, 0, sizeof(timer_config));
    timer_config.clk_src = GPTIMER_CLK_SRC_DEFAULT;
    timer_config.direction = GPTIMER_COUNT_UP;
    timer_config.resolution_hz = 1 * 1000 * 1000; // 1MHz, 1 tick = 1us

    gptimer_new_timer(&timer_config, &timer_handle);

    if (NULL == timer_handle) {
        return OPRT_COM_ERROR;
    }

    s_timer_dev[timer_id].time_handle = timer_handle;
   
    return OPRT_OK; 
}

/**
 * @brief timer start
 * 
 * @param[in] timer_id timer id
 * @param[in] us when to start
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_timer_start(TUYA_TIMER_NUM_E timer_id, UINT_T us)
{
    gptimer_alarm_config_t alarm_config;
    gptimer_event_callbacks_t alarm_cbs;

    if (timer_id >= TIMER_DEV_NUM) {                             
        return OPRT_INVALID_PARM;                       
    } 

    if (NULL == s_timer_dev[timer_id].time_handle) {
        return OPRT_INVALID_PARM;
    }

    memset(&alarm_config, 0, sizeof(alarm_config));

    alarm_config.reload_count = 0;
    alarm_config.alarm_count = us;
    alarm_config.flags.auto_reload_on_alarm = s_timer_dev[timer_id].timer_cfg->cfg.mode;

    gptimer_set_alarm_action(s_timer_dev[timer_id].time_handle, &alarm_config);
    alarm_cbs.on_alarm = tkl_timer_handle;
    gptimer_register_event_callbacks(s_timer_dev[timer_id].time_handle, &alarm_cbs, &timer_id);
    gptimer_enable(s_timer_dev[timer_id].time_handle);
    gptimer_start(s_timer_dev[timer_id].time_handle);

    return OPRT_OK;
}

/**
 * @brief timer stop
 * 
 * @param[in] timer_id timer id
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_timer_stop(TUYA_TIMER_NUM_E timer_id)
{
    if (timer_id >= TIMER_DEV_NUM) {                             
        return OPRT_INVALID_PARM;                       
    } 

    if (NULL == s_timer_dev[timer_id].time_handle) {
        return OPRT_INVALID_PARM;
    }

    gptimer_stop(s_timer_dev[timer_id].time_handle);
    gptimer_disable(s_timer_dev[timer_id].time_handle);


    return OPRT_OK;
}

/**
 * @brief timer deinit
 * 
 * @param[in] timer_id timer id
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_timer_deinit(TUYA_TIMER_NUM_E timer_id)
{
    if (timer_id >= TIMER_DEV_NUM) {                             
        return OPRT_INVALID_PARM;                       
    } 

    if (NULL == s_timer_dev[timer_id].time_handle) {
        return OPRT_INVALID_PARM;
    }

    gptimer_del_timer(s_timer_dev[timer_id].time_handle);

    if (NULL != s_timer_dev[timer_id].timer_cfg) {
        tkl_system_free(s_timer_dev[timer_id].timer_cfg);
    }

    s_timer_dev[timer_id].timer_cfg = NULL;
    s_timer_dev[timer_id].time_handle = NULL;    
    return OPRT_OK;
}

/**
 * @brief timer get
 * 
 * @param[in] timer_id timer id
 * @param[out] ms timer interval
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_timer_get(TUYA_TIMER_NUM_E timer_id, UINT_T *us)
{
    CHECK_TIMER_PARAM(timer_id);
    *us = s_timer_dev[timer_id].timer_cfg->us;
     return OPRT_OK;
}

/**
 * @brief current timer get
 * 
 * @param[in] timer_id timer id
 * @param[out] us timer 
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_timer_get_current_value(TUYA_TIMER_NUM_E timer_id, UINT_T *us)
{
    return OPRT_NOT_SUPPORTED;    
}

