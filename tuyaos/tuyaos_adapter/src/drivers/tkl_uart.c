/**
 * @file tkl_uart.c
 * @brief this file was auto-generated by tuyaos v&v tools, developer can add implements between BEGIN and END
 * 
 * @warning: changes between user 'BEGIN' and 'END' will be keeped when run tuyaos v&v tools
 *           changes in other place will be overwrited and lost
 *
 * @copyright Copyright 2020-2021 Tuya Inc. All Rights Reserved.
 * 
 */

// --- BEGIN: user defines and implements ---
#include "tkl_uart.h"
#include "tuya_error_code.h"
#include "freertos/FreeRTOS.h"
#include "freertos/portmacro.h"
#include "esp_log.h"
#include "driver/uart.h"
// #include "driver/gpio.h"
#include "soc/gpio_num.h"

#define MAX_UART_NUM 2

#if 1
#define TKL_UART_NUM_0_TXD  (GPIO_NUM_1)
#define TKL_UART_NUM_0_RXD  (GPIO_NUM_3)
#define TKL_UART_NUM_0_RTS  (UART_PIN_NO_CHANGE)
#define TKL_UART_NUM_0_CTS  (UART_PIN_NO_CHANGE)
#else
#define TKL_UART_NUM_0_TXD  (GPIO_NUM_43)
#define TKL_UART_NUM_0_RXD  (GPIO_NUM_44)
#define TKL_UART_NUM_0_RTS  (UART_PIN_NO_CHANGE)
#define TKL_UART_NUM_0_CTS  (UART_PIN_NO_CHANGE)
#endif


#define TKL_UART_NUM_1_TXD  (GPIO_NUM_17)
#define TKL_UART_NUM_1_RXD  (GPIO_NUM_18)
#define TKL_UART_NUM_1_RTS  (UART_PIN_NO_CHANGE)
#define TKL_UART_NUM_1_CTS  (UART_PIN_NO_CHANGE)

TaskHandle_t tkl_uart_thread = NULL;
TUYA_UART_IRQ_CB uart_rx_cb[MAX_UART_NUM];
QueueHandle_t tkl_uart_rx_queue = NULL;

#define DBG_TAG "TKL_UART"
// --- END: user defines and implements ---

static void tkl_uart_rx_process(void *args)
{
    uart_port_t uart_num = UART_NUM_0;
    uart_event_t event;
    
    assert(NULL != args);
    uart_num = *(uart_port_t *)args;

    while (tkl_uart_rx_queue && xQueueReceive(tkl_uart_rx_queue, (void * )&event, portMAX_DELAY)) {
        switch (event.type) {
        case UART_DATA:
            if (uart_rx_cb[uart_num]) {
                uart_rx_cb[uart_num](uart_num);
            }
            break;
        case UART_BREAK:
            break;
        case UART_BUFFER_FULL:
            break;
        case UART_FIFO_OVF:
            break;
        case UART_FRAME_ERR:
            break;
        case UART_PARITY_ERR:
            break;
        case UART_DATA_BREAK:
            break;
        case UART_PATTERN_DET:
            break;
        default:
            break;                
        } /* switch (event.type) { */
    }
    vTaskDelete(NULL);
}

/**
 * @brief uart init
 * 
 * @param[in] port_id: uart port id, id index starts at 0
 *                     in linux platform, 
 *                         high 16 bits aslo means uart type, 
 *                                   it's value must be one of the TUYA_UART_TYPE_E type
 *                         the low 16bit - means uart port id
 *                         you can input like this TUYA_UART_PORT_ID(TUYA_UART_SYS, 2)
 * @param[in] cfg: uart config
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_uart_init(TUYA_UART_NUM_E port_id, TUYA_UART_BASE_CFG_T *cfg)
{
    // --- BEGIN: user implements ---
    esp_err_t ret;
 	uart_port_t uart_num;
	uart_config_t uart_cfg;
    int intr_alloc_flags = 0, uart_txd, uart_rxd, uart_rts, uart_cts;
    
   if (cfg == NULL)
        return OPRT_INVALID_PARM;
    
    uart_num = (uart_port_t)port_id;
    if (uart_num >= MAX_UART_NUM) {
        return OPRT_INVALID_PARM;
    }

    if (TUYA_UART_DATA_LEN_5BIT == cfg->databits) {
        uart_cfg.data_bits = UART_DATA_5_BITS;
    } else if (TUYA_UART_DATA_LEN_6BIT == cfg->databits) {
        uart_cfg.data_bits = UART_DATA_6_BITS;
    } else if (TUYA_UART_DATA_LEN_7BIT ==  cfg->databits) {
        uart_cfg.data_bits = UART_DATA_7_BITS;
    } else if (TUYA_UART_DATA_LEN_8BIT == cfg->databits) {
        uart_cfg.data_bits = UART_DATA_8_BITS;
    } else {
        return OPRT_INVALID_PARM;
    }

    if (TUYA_UART_STOP_LEN_1BIT == cfg->stopbits) {
        uart_cfg.stop_bits = UART_STOP_BITS_1;
    } else if (TUYA_UART_STOP_LEN_2BIT == cfg->stopbits) {
        uart_cfg.stop_bits = UART_STOP_BITS_2;
    } else if (TUYA_UART_STOP_LEN_1_5BIT1 == cfg->stopbits) {
        uart_cfg.stop_bits = UART_STOP_BITS_1_5;
    } else {
        return OPRT_INVALID_PARM;
    }

    if (TUYA_UART_PARITY_TYPE_NONE == cfg->parity) {
        uart_cfg.parity = UART_PARITY_DISABLE;
    } else if (TUYA_UART_PARITY_TYPE_EVEN == cfg->parity) {
        uart_cfg.parity = UART_PARITY_EVEN;
    } else if (TUYA_UART_PARITY_TYPE_ODD == cfg->parity) {
        uart_cfg.parity = UART_PARITY_ODD;
    } else {
        return OPRT_INVALID_PARM;
    }

    uart_cfg.baud_rate = cfg->baudrate;
    uart_cfg.rx_flow_ctrl_thresh = 122;
	uart_cfg.flow_ctrl = UART_HW_FLOWCTRL_DISABLE;
	uart_cfg.source_clk = UART_SCLK_DEFAULT;
    // uart_cfg.source_clk = UART_SCLK_XTAL;

    if (UART_NUM_1 == uart_num) {
        uart_txd = TKL_UART_NUM_1_TXD;
        uart_rxd = TKL_UART_NUM_1_RXD;
        uart_cts = TKL_UART_NUM_1_CTS;
        uart_rts = TKL_UART_NUM_1_RTS;
    } else {
        uart_txd = TKL_UART_NUM_0_TXD;
        uart_rxd = TKL_UART_NUM_0_RXD;
        uart_cts = TKL_UART_NUM_0_CTS;
        uart_rts = TKL_UART_NUM_0_RTS;
    }

    ret = uart_param_config(uart_num, &uart_cfg);
    if (ESP_OK != ret) {
        ESP_LOGE(DBG_TAG, "%s: call uart_param_config failed(uart_num=%d,ret=%d)", __func__, uart_num, ret);
        return OPRT_COM_ERROR;
    }

    ret = uart_set_pin(uart_num, uart_txd, uart_rxd, uart_rts, uart_cts);
    if (ESP_OK != ret) {
        ESP_LOGE(DBG_TAG, "%s: call uart_set_pin failed(ret=%d)", __func__, ret);
        return OPRT_COM_ERROR;
    }
    
    ret = uart_driver_install(uart_num, 256, 0, 10, &tkl_uart_rx_queue, intr_alloc_flags);
    if (ESP_OK != ret) {
        ESP_LOGE(DBG_TAG, "%s: call uart_driver_install failecd(ret=%d)", __func__, ret);
        return OPRT_COM_ERROR;
    }
    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief uart deinit
 * 
 * @param[in] port_id: uart port id, id index starts at 0
 *                     in linux platform, 
 *                         high 16 bits aslo means uart type, 
 *                                   it's value must be one of the TUYA_UART_TYPE_E type
 *                         the low 16bit - means uart port id
 *                         you can input like this TUYA_UART_PORT_ID(TUYA_UART_SYS, 2)
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_uart_deinit(TUYA_UART_NUM_E port_id)
{
    // --- BEGIN: user implements ---
    uart_port_t uart_num = (uart_port_t)port_id;
    if (uart_num > MAX_UART_NUM)
        return OPRT_INVALID_PARM;
    
    if (ESP_OK != uart_disable_rx_intr(uart_num)) {
        ESP_LOGE(DBG_TAG, "%s: call uart_disable_rx_intr failed", __func__);
        //return OPRT_COM_ERROR;
    }

    if (ESP_OK != uart_driver_delete(uart_num)) {
        ESP_LOGE(DBG_TAG, "%s: call uart_driver_delete failed", __func__);
        return OPRT_COM_ERROR;
    }

    if (NULL != tkl_uart_thread) {
        vTaskDelete(tkl_uart_thread);
        tkl_uart_thread = NULL;
    }
    tkl_uart_rx_queue = NULL;
    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief uart write data
 * 
 * @param[in] port_id: uart port id, id index starts at 0
 *                     in linux platform, 
 *                         high 16 bits aslo means uart type, 
 *                                   it's value must be one of the TUYA_UART_TYPE_E type
 *                         the low 16bit - means uart port id
 *                         you can input like this TUYA_UART_PORT_ID(TUYA_UART_SYS, 2)
 * @param[in] data: write buff
 * @param[in] len:  buff len
 *
 * @return return > 0: number of data written; return <= 0: write errror
 */
INT_T tkl_uart_write(TUYA_UART_NUM_E port_id, VOID_T *buff, UINT16_T len)
{
    // --- BEGIN: user implements ---
    int ret;
    uart_port_t  uart_num = (uart_port_t)port_id; 
    if (NULL == buff || 0 == len || uart_num > MAX_UART_NUM) {
        return OPRT_INVALID_PARM;
    }

    // Write data back to the UART
    ret = uart_write_bytes(uart_num, (const char *)buff, len);
    if (ret < 0) {
        ESP_LOGI(DBG_TAG, "%s: uart_write_bytes failed(ret=%d)", __func__, ret);
    }
    return ret;
    // --- END: user implements ---
}

/**
 * @brief enable uart rx interrupt and regist interrupt callback
 * 
 * @param[in] port_id: uart port id, id index starts at 0
 *                     in linux platform, 
 *                         high 16 bits aslo means uart type, 
 *                                   it's value must be one of the TUYA_UART_TYPE_E type
 *                         the low 16bit - means uart port id
 *                         you can input like this TUYA_UART_PORT_ID(TUYA_UART_SYS, 2)
 * @param[in] rx_cb: receive callback
 *
 * @return none
 */
VOID_T tkl_uart_rx_irq_cb_reg(TUYA_UART_NUM_E port_id, TUYA_UART_IRQ_CB rx_cb)
{
    // --- BEGIN: user implements ---
    BaseType_t ret;
    uart_port_t  uart_num = (uart_port_t)port_id; 

    if (NULL == rx_cb || uart_num > MAX_UART_NUM) {
        ESP_LOGI(DBG_TAG, "%s: rx_cb is NULL", __func__);
        return ;
    }

    if (NULL != tkl_uart_thread) {
        ESP_LOGI(DBG_TAG, "%s: tkl_uart_thread is running", __func__);
        vTaskDelete(tkl_uart_thread);
        tkl_uart_thread = NULL;
        return ;
    }

    ret = xTaskCreate(tkl_uart_rx_process, "tkl_uart_thread", 4096, &uart_num, 4, &tkl_uart_thread);
    if (ret != pdPASS) {
        ESP_LOGI(DBG_TAG, "%s: xTaskCreate failed", __func__);
        return ;
    }

    uart_enable_rx_intr(uart_num);
    uart_rx_cb[uart_num] = rx_cb;
    // --- END: user implements ---
}

/**
 * @brief regist uart tx interrupt callback
 * If this function is called, it indicates that the data is sent asynchronously through interrupt,
 * and then write is invoked to initiate asynchronous transmission.
 *  
 * @param[in] port_id: uart port id, id index starts at 0
 *                     in linux platform, 
 *                         high 16 bits aslo means uart type, 
 *                                   it's value must be one of the TUYA_UART_TYPE_E type
 *                         the low 16bit - means uart port id
 *                         you can input like this TUYA_UART_PORT_ID(TUYA_UART_SYS, 2)
 * @param[in] rx_cb: receive callback
 *
 * @return none
 */
VOID_T tkl_uart_tx_irq_cb_reg(TUYA_UART_NUM_E port_id, TUYA_UART_IRQ_CB tx_cb)
{
    // --- BEGIN: user implements ---
    return ;
    // --- END: user implements ---
}

/**
 * @brief uart read data
 * 
 * @param[in] port_id: uart port id, id index starts at 0
 *                     in linux platform, 
 *                         high 16 bits aslo means uart type, 
 *                                   it's value must be one of the TUYA_UART_TYPE_E type
 *                         the low 16bit - means uart port id
 *                         you can input like this TUYA_UART_PORT_ID(TUYA_UART_SYS, 2)
 * @param[out] data: read data
 * @param[in] len:  buff len
 * 
 * @return return >= 0: number of data read; return < 0: read errror
 */
INT_T tkl_uart_read(TUYA_UART_NUM_E port_id, VOID_T *buff, UINT16_T len)
{
    // --- BEGIN: user implements ---
    int ret;
    uart_port_t uart_num = (uart_port_t)port_id;
    if (NULL == buff || 0 == len || uart_num > MAX_UART_NUM) {
        return OPRT_INVALID_PARM;
    }

    // Read data from the UART
    ret = uart_read_bytes(uart_num, buff, len, 20 / portTICK_PERIOD_MS);
    if (ret < 0) {
        ESP_LOGI(DBG_TAG, "%s: uart_read_bytes failed(ret=%d)", __func__, ret);
    }
    return ret;
    // --- END: user implements ---
}

/**
 * @brief set uart transmit interrupt status
 * 
 * @param[in] port_id: uart port id, id index starts at 0
 *                     in linux platform, 
 *                         high 16 bits aslo means uart type, 
 *                                   it's value must be one of the TUYA_UART_TYPE_E type
 *                         the low 16bit - means uart port id
 *                         you can input like this TUYA_UART_PORT_ID(TUYA_UART_SYS, 2)
 * @param[in] enable: TRUE-enalbe tx int, FALSE-disable tx int
 * 
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_uart_set_tx_int(TUYA_UART_NUM_E port_id, BOOL_T enable)
{
    // --- BEGIN: user implements ---
    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief set uart receive flowcontrol
 * 
 * @param[in] port_id: uart port id, id index starts at 0
 *                     in linux platform, 
 *                         high 16 bits aslo means uart type, 
 *                                   it's value must be one of the TUYA_UART_TYPE_E type
 *                         the low 16bit - means uart port id
 *                         you can input like this TUYA_UART_PORT_ID(TUYA_UART_SYS, 2)
 * @param[in] enable: TRUE-enalbe rx flowcontrol, FALSE-disable rx flowcontrol
 * 
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_uart_set_rx_flowctrl(TUYA_UART_NUM_E port_id, BOOL_T enable)
{
    // --- BEGIN: user implements ---
    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief wait for uart data
 * 
 * @param[in] port_id: uart port id, id index starts at 0
 *                     in linux platform, 
 *                         high 16 bits aslo means uart type, 
 *                                   it's value must be one of the TUYA_UART_TYPE_E type
 *                         the low 16bit - means uart port id
 *                         you can input like this TUYA_UART_PORT_ID(TUYA_UART_SYS, 2)
 * @param[in] timeout_ms: the max wait time, unit is millisecond
 *                        -1 : block indefinitely
 *                        0  : non-block
 *                        >0 : timeout in milliseconds
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_uart_wait_for_data(TUYA_UART_NUM_E port_id, INT_T timeout_ms)
{
    // --- BEGIN: user implements ---
    return OPRT_NOT_SUPPORTED;
    // --- END: user implements ---
}

/**
 * @brief uart control
 *
 * @param[in] uart refer to tuya_uart_t
 * @param[in] cmd control command
 * @param[in] arg command argument
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_uart_ioctl(TUYA_UART_NUM_E port_id, UINT32_T cmd, VOID *arg)
{
    // --- BEGIN: user implements ---
    return OPRT_NOT_SUPPORTED;
    // --- END: user implements ---
}

